// Assumes polyglot.jar is in classpath
include "polyglot/parse/java12.cup"

package edu.buffalo.cse.blue.maybe.parse;

import edu.buffalo.cse.blue.maybe.types.MaybeTypeSystem;
import edu.buffalo.cse.blue.maybe.ast.MaybeNodeFactory;
import edu.buffalo.cse.blue.maybe.ast.Maybe;
import polyglot.parse.Name;
import polyglot.parse.VarDeclarator;

parser Grm extends polyglot.parse.Grm {:
    public final MaybeTypeSystem ts;
    public final MaybeNodeFactory nf;

    public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
        super(l, t, n, q);
        ts = (MaybeTypeSystem) t;
        nf = (MaybeNodeFactory) n;
    }

    public Maybe Maybe(Position pos, Expr cond, List<Block> alternatives) throws Exception {
        return nf.Maybe(pos, cond, alternatives);
    }
:};

terminal Token MAYBE, MAYBEOR;
non terminal Maybe maybe_statement;
non terminal List<Block> maybe_clauses;
// non terminal List<Block> maybe_clauses, maybe_opt;

start with goal;

// TODO: modify the default Java grammar using PPG operations

// extend statement ::=
//    maybe_statement:a {:  RESULT = a;  :};
//
// extend statement_no_short_if ::=
//    maybe_statement_no_short_if:a {:  RESULT = a;  :};

extend statement_without_trailing_substatement ::=
    maybe_statement:a
        {: RESULT = a; :}
;

maybe_statement ::=
// extend if_then_else_statement ::=
    // MAYBE:n LPAREN expression:a RPAREN statement_no_short_if:b maybe_clauses:c
    MAYBE:n LPAREN expression:a RPAREN maybe_clauses:b
    {:
        RESULT = parser.nf.Maybe(parser.pos(n, b), a, b);
    :}
;

// extend statement ::=
//     maybe_clauses:a
//         {: RESULT = a; :}
// ;


// maybe_statement ::=
//     MAYBE:n LPAREN expression:a RPAREN block:b maybe_clauses:c
//             {: RESULT = parser.nf.Maybe(parser.pos(n, c), a, b, c); :}
//     ;

// maybe_opt ::=
//     block:a
//             {: RESULT = new LinkedList<>(); :}
//     |   maybe_clauses:a
//             {: RESULT = a; :}
//     ;

maybe_clauses ::=
    // List of maybe catch
    block:a
        {: List<Block> l = new LinkedList<>();
            l.add(a);
            RESULT = l; :}
    |   maybe_clauses:a MAYBEOR block:b
        {: RESULT = a;
           a.add(b); :}
    ;

// switch_statement ::=
//     SWITCH:n LPAREN expression:a RPAREN:rprn switch_block:b {:
//
//                Position endpos = parser.pos(n, b);
//                if (endpos == null) endpos = parser.pos(n, rprn);
//                RESULT = parser.nf.Switch(endpos, a, b);
//
//                                                             :};
//
// switch_block ::=
//     LBRACE switch_block_statement_groups:a switch_labels:b RBRACE {:
//                                                                   RESULT = a;
//                a.addAll(b);
//                                                                   :}
//  |  LBRACE switch_block_statement_groups:a RBRACE {:  RESULT = a;  :}
//  |  LBRACE switch_labels:a RBRACE {:  RESULT = a;  :}
//  |  LBRACE RBRACE {:  RESULT = new LinkedList<>();  :};
//
// switch_block_statement_groups ::=
//     switch_block_statement_group:a {:  RESULT = a;  :}
//  |  switch_block_statement_groups:a switch_block_statement_group:b {:
//                                                                    RESULT = a;
//                a.addAll(b);
//                                                                    :};
//
// switch_block_statement_group ::=
//     switch_labels:a block_statements:b {:
//                                        List<SwitchElement> l = new LinkedList<>();
//                l.addAll(a);
//                l.add(parser.nf.SwitchBlock(parser.pos(a, b), b));
//                RESULT = l;
//                                        :};
//
// switch_labels ::=
//     switch_label:a {:
//                    List<SwitchElement> l = new LinkedList<>();
//                l.add(a);
//                RESULT = l;
//                    :}
//  |  switch_labels:a switch_label:b {:  RESULT = a;
//                a.add(b);  :};
//
// switch_label ::=
//     CASE:n constant_expression:a COLON:d {:
//                                          RESULT = parser.nf.Case(parser.pos(n, d), a);
//                                          :}
//  |  DEFAULT:n COLON:d {:  RESULT = parser.nf.Default(parser.pos(n, d));  :};
